// Generated by Haxe 3.4.0
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
var TestDungeon = function() { };
TestDungeon.__name__ = true;
TestDungeon.main = function() {
	console.log("Building map.");
	var _g = new haxe_ds_IntMap();
	_g.h[0] = " ";
	_g.h[1] = "|";
	_g.h[2] = "#";
	_g.h[3] = "_";
	var generator = new util_DungeonWorldGenerator(100,100);
	var _g2 = 0;
	var _g1 = generator.width;
	while(_g2 < _g1) {
		var y = _g2++;
		var _g4 = 0;
		var _g3 = generator.height;
		while(_g4 < _g3) TestDungeon.print(_g.h[generator.tiles[y * generator.width + _g4++]]);
		TestDungeon.print("\n");
	}
};
TestDungeon.print = function(text) {
	window.document.getElementById("map").innerText += text;
};
var Type = function() { };
Type.__name__ = true;
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw new js__$Boot_HaxeError("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw new js__$Boot_HaxeError("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw new js__$Boot_HaxeError("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c = e.__constructs__[index];
	if(c == null) {
		throw new js__$Boot_HaxeError(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0?",":"") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var util_Side = { __ename__ : true, __constructs__ : ["Left","Right","Top","Bottom"] };
util_Side.Left = ["Left",0];
util_Side.Left.__enum__ = util_Side;
util_Side.Right = ["Right",1];
util_Side.Right.__enum__ = util_Side;
util_Side.Top = ["Top",2];
util_Side.Top.__enum__ = util_Side;
util_Side.Bottom = ["Bottom",3];
util_Side.Bottom.__enum__ = util_Side;
var util_DungeonWorldGenerator = function(width,height) {
	this.fails = 0;
	this.rooms = [];
	this.tiles = [];
	this.width = width;
	this.height = height;
	this.generate();
};
util_DungeonWorldGenerator.__name__ = true;
util_DungeonWorldGenerator.prototype = {
	roomPlacementValid: function(room) {
		var _g = 0;
		var _g1 = this.rooms;
		while(_g < _g1.length) {
			var r = _g1[_g];
			++_g;
			if(r.x < room.x + room.width - 1 && r.x + r.width - 1 > room.x && r.y < room.y + room.height - 1 && r.height - 1 + r.y > room.y) {
				return false;
			}
		}
		if(room.x >= 0 && room.y >= 0 && room.x + room.width < this.width) {
			return room.y + room.height < this.height;
		} else {
			return false;
		}
	}
	,generate: function() {
		this.createMap();
		this.rooms.push({ x : 30, y : 30, width : 4, height : 4, attachedFromSide : null, doorways : []});
		this.growFromRoom(this.rooms[0]);
		var _g = 0;
		var _g1 = this.rooms;
		while(_g < _g1.length) {
			var room = _g1[_g];
			++_g;
			var _g3 = 0;
			var _g2 = room.width;
			while(_g3 < _g2) {
				var x = _g3++;
				var _g5 = 0;
				var _g4 = room.height;
				while(_g5 < _g4) {
					var y = _g5++;
					if(this.tiles[(room.y + y) * this.width + (room.x + x)] != 0) {
						continue;
					}
					this.tiles[(room.y + y) * this.width + (room.x + x)] = 3;
					if(x == 0 || y == 0 || x == room.width - 1 || y == room.height - 1) {
						this.tiles[(room.y + y) * this.width + (room.x + x)] = 2;
					}
					var _g6 = 0;
					var _g7 = room.doorways;
					while(_g6 < _g7.length) {
						var doorway = _g7[_g6];
						++_g6;
						if(room.x + x == doorway.x && room.y + y == doorway.y) {
							this.tiles[(room.y + y) * this.width + (room.x + x)] = 3;
						}
					}
				}
			}
		}
		var _g8 = 0;
		var _g11 = this.rooms;
		while(_g8 < _g11.length) {
			var room1 = _g11[_g8];
			++_g8;
			var _g21 = 0;
			var _g31 = room1.doorways;
			while(_g21 < _g31.length) {
				var door = _g31[_g21];
				++_g21;
				this.tiles[door.y * this.width + door.x] = 1;
			}
		}
	}
	,fail: function() {
		this.fails++;
		return this.fails < 400;
	}
	,growFromRoom: function(room) {
		var side = Type.createEnumIndex(util_Side,Math.floor(Math.random() * 4),null);
		while(side == room.attachedFromSide) side = Type.createEnumIndex(util_Side,Math.floor(Math.random() * 4),null);
		var width = 8 + Math.floor(Math.random() * 5);
		var height = 8 + Math.floor(Math.random() * 5);
		var doorx = room.x + Math.floor(Math.min(room.width / 2,width / 2));
		var doory = room.y + Math.floor(Math.min(room.height / 2,height / 2));
		if(Math.random() > .25) {
			console.log("R");
			var newRoom = { attachedFromSide : util_Side.Left, doorways : [{ x : room.x + room.width - 1, y : doory}], x : room.x + room.width - 1, y : room.y, width : width, height : height};
			if(this.roomPlacementValid(newRoom)) {
				this.rooms.push(newRoom);
				this.growFromRoom(newRoom);
			} else if(this.fail()) {
				this.growFromRoom(room);
			}
		}
		if(Math.random() > .25) {
			console.log("B");
			var newRoom1 = { attachedFromSide : util_Side.Top, doorways : [{ x : doorx, y : room.y + room.height - 1}], x : room.x, y : room.y + room.height - 1, width : width, height : height};
			if(this.roomPlacementValid(newRoom1)) {
				this.rooms.push(newRoom1);
				this.growFromRoom(newRoom1);
			} else if(this.fail()) {
				this.growFromRoom(room);
			}
		}
		if(Math.random() > .25) {
			console.log("L");
			var newRoom2 = { attachedFromSide : util_Side.Right, doorways : [{ x : room.x, y : doory}], x : room.x - width + 1, y : room.y, width : width, height : height};
			if(this.roomPlacementValid(newRoom2)) {
				this.rooms.push(newRoom2);
				this.growFromRoom(newRoom2);
			} else if(this.fail()) {
				this.growFromRoom(room);
			}
		}
		if(Math.random() > .25) {
			console.log("T");
			var newRoom3 = { attachedFromSide : util_Side.Bottom, doorways : [{ x : doorx, y : room.y}], x : room.x, y : room.y - height + 1, width : width, height : height};
			if(this.roomPlacementValid(newRoom3)) {
				this.rooms.push(newRoom3);
				this.growFromRoom(newRoom3);
			} else if(this.fail()) {
				this.growFromRoom(room);
			}
		}
	}
	,createMap: function() {
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			++_g1;
			var _g3 = 0;
			var _g2 = this.width;
			while(_g3 < _g2) {
				++_g3;
				this.tiles.push(0);
			}
		}
	}
	,bakerooms: function() {
		var _g = 0;
		var _g1 = this.rooms;
		while(_g < _g1.length) {
			var room = _g1[_g];
			++_g;
			var _g3 = 0;
			var _g2 = room.width;
			while(_g3 < _g2) {
				var x = _g3++;
				var _g5 = 0;
				var _g4 = room.height;
				while(_g5 < _g4) {
					var y = _g5++;
					if(this.tiles[(room.y + y) * this.width + (room.x + x)] != 0) {
						continue;
					}
					this.tiles[(room.y + y) * this.width + (room.x + x)] = 3;
					if(x == 0 || y == 0 || x == room.width - 1 || y == room.height - 1) {
						this.tiles[(room.y + y) * this.width + (room.x + x)] = 2;
					}
					var _g6 = 0;
					var _g7 = room.doorways;
					while(_g6 < _g7.length) {
						var doorway = _g7[_g6];
						++_g6;
						if(room.x + x == doorway.x && room.y + y == doorway.y) {
							this.tiles[(room.y + y) * this.width + (room.x + x)] = 3;
						}
					}
				}
			}
		}
		var _g8 = 0;
		var _g11 = this.rooms;
		while(_g8 < _g11.length) {
			var room1 = _g11[_g8];
			++_g8;
			var _g21 = 0;
			var _g31 = room1.doorways;
			while(_g21 < _g31.length) {
				var door = _g31[_g21];
				++_g21;
				this.tiles[door.y * this.width + door.x] = 1;
			}
		}
	}
	,set: function(x,y,i) {
		this.tiles[y * this.width + x] = i;
	}
	,get: function(x,y) {
		return this.tiles[y * this.width + x];
	}
	,roomsTouch: function(room1,room2) {
		if(room1.x < room2.x + room2.width - 1 && room1.x + room1.width - 1 > room2.x && room1.y < room2.y + room2.height - 1) {
			return room1.height - 1 + room1.y > room2.y;
		} else {
			return false;
		}
	}
	,pointInRoom: function(room,pointx,pointy) {
		if(pointx > room.x && pointx < room.x + room.width && pointy > room.y) {
			return pointy < room.y + room.height;
		} else {
			return false;
		}
	}
};
String.__name__ = true;
Array.__name__ = true;
TestDungeon.main();
})();
